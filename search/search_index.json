{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> \u269c\ufe0f Clientele Typed API Clients from OpenAPI schemas </p> <p> </p> <p>Clientele lets you generate fully-typed, functional, API Clients from OpenAPI schemas.</p> <p>It uses modern tools to be blazing fast and type safe.</p> <p>Plus - there is no complex boilerplate and the generated code is very small.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fully typed API Client using Pydantic.</li> <li>Minimalist and easy to use - the generated code is designed for readability.</li> <li>Choose either sync or async - we support both, and you can switch between them easily.</li> <li>Supports authentication (curently only HTTP Bearer and HTTP Basic auth).</li> <li>Written entirely in Python - no need to install other languages to use OpenAPI.</li> <li>The client footprint is minimal - it only requires <code>httpx</code> and <code>pydantic</code>.</li> <li>Supports your own configuration - we provide an entry point that will never be overwritten.</li> </ul> <p>We're built on:</p> <ul> <li>Pydantic 2.0</li> <li>httpx</li> <li>openapi-core</li> </ul>"},{"location":"CHANGELOG/","title":"Change log","text":""},{"location":"CHANGELOG/#041","title":"0.4.1","text":"<ul> <li>Correctly generate lists of nested schema classes</li> <li>Correctly build response schemas that are emphemeral (such as when they just return an array of other schemas, or when they have no $ref).</li> </ul>"},{"location":"CHANGELOG/#040","title":"0.4.0","text":"<ul> <li>Change install suggestion to use pipx as it works best as a global CLI tool.</li> <li>Improved support for OpenAPI 3.0.3 schemas (a test version is available in the example_openapi_specs directory).</li> <li><code>validate</code> command for validating an OpenAPI schema will work with clientele.</li> <li><code>version</code> command for showing the current version of clientele.</li> <li>Supports HTTP DELETE methods.</li> <li>Big refactor of how methods are generated to reduce duplicate code.</li> <li>Support optional header parameters in all request functions (where they are required).</li> <li>Very simple Oauth2 support - if it is discovered will set up HTTP Bearer auth for you.</li> <li>Uses <code>dict</code> and <code>list</code> instead of <code>typing.Dict</code> and <code>typing.List</code> respectively.</li> <li>Improved schema generation when schemas have $ref to other models.</li> </ul>"},{"location":"CHANGELOG/#032","title":"0.3.2","text":"<ul> <li>Minor changes to function name generation to make it more consistent.</li> <li>Optional parameters in schemas are working properly.</li> </ul>"},{"location":"CHANGELOG/#031","title":"0.3.1","text":"<ul> <li>Fixes a bug when generating HTTP Authentication schema.</li> <li>Fixes a bug when generating input classes for post functions, when the input schema doesn't exist yet.</li> <li>Generates pythonic function names in clients now, always (like <code>lower_case_snake_case</code>).</li> </ul>"},{"location":"CHANGELOG/#030","title":"0.3.0","text":"<ul> <li>Now generates a <code>MANIFEST</code> file with information about the build versions</li> <li>Added a <code>constants.py</code> file to the output if one does not exist yet, which can be used to store values that you do not want to change between subsequent re-generations of the clientele client, such as the API base url.</li> <li>Authentication patterns now use <code>constants.py</code> for constants values.</li> <li>Removed <code>ipython</code> from package dependencies and moved to dev dependencies.</li> <li>Documentation! https://phalt.github.io/clientele/</li> </ul>"},{"location":"CHANGELOG/#020","title":"0.2.0","text":"<ul> <li>Improved CLI output</li> <li>Code organisation is now sensible and not just one giant file</li> <li>Now supports an openapi spec generated from a dotnet project (<code>Microsoft.OpenApi.Models</code>)</li> <li>async client support  fully working</li> <li>HTTP Bearer support</li> <li>HTTP Basic support</li> </ul>"},{"location":"CHANGELOG/#010","title":"0.1.0","text":"<ul> <li>Initial version</li> <li>Mostly works with a simple FastAPI generated spec (3.0.2)</li> <li>Works with Twilio's spec (see example_openapi_specs/ directory) (3.0.1)</li> <li>Almost works with stripes</li> </ul>"},{"location":"compatibility/","title":"\ud83d\udcb1 Compatability","text":"<p>When we were building Clientele, we discovered that, despite a fantastic specification, OpenAPI has a lot of poor implementations.</p> <p>As pythonistas, we started with the auto-generated OpenAPI schemas provided by FastAPI, and then we branched out to large APIs like Twilio to test what we built.</p> <p>Despite the effort, we still keep finding subtly different OpenAPI implementations. Because of this we cannot guarentee 100% compatability with an API, but we can give you a good indication of what we've tested.</p>"},{"location":"compatibility/#works-well-with","title":"Works well with","text":"<p>Any bog-standard <code>3.0.x</code> implementation works very well.</p> <ul> <li>FastAPI's OpenAPI schema is very well supported.</li> <li>Microsoft's OpenAPI spec has also been battle tested on an internal project, and works well.</li> </ul>"},{"location":"compatibility/#does-not-work","title":"Does not work","text":"<p>We do not support <code>2.x</code> aka \"Swagger\" - this format is quite different and deprecated.</p>"},{"location":"examples/","title":"\ud83e\ude84 Client example","text":"<p>Let's build an API Client using clientele and an example OpenAPI schema.</p> <p>Our GitHub has a bunch of schemas that are proven to work with clientele, so let's use one of those!</p>"},{"location":"examples/#generate-the-client","title":"Generate the client","text":"<p>Very simply:</p> <pre><code>clientele generate -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/simple.json -o my_client/\n</code></pre> <p>The <code>-u</code> parameter expects a URL, you can provide a path to a file with <code>-f</code> instead if you download the file.</p> <p>The <code>-o</code> parameter is the output directory of the generated client.</p> <p>Run it now and you will see this output:</p> <pre><code>my_client/\n    __init__.py\n    client.py\n    constants.py\n    http.py\n    MANIFEST\n    schemas.py\n</code></pre>"},{"location":"examples/#client-directory","title":"Client directory","text":"<p>Let's go over each file and talk about what it does</p>"},{"location":"examples/#clientpy","title":"client.py","text":"<p>This file provides all the client functions.</p> my_client/client.py<pre><code>import typing  # noqa\nfrom . import schemas  # noqa\nfrom . import http  # noqa\ndef HealthCheckHealthCheckGet() -&gt; schemas.HealthCheckResponse:\nresponse = http.get(\"/health-check\")\nreturn http.handle_response(HealthCheckHealthCheckGet, response)\ndef TestInputTestInputPost(\ndata: schemas.TestInputData,\n) -&gt; typing.Union[schemas.HTTPValidationError, schemas.TestInputResponse]:\nresponse = http.post(\"/test-input\", data=data and data.model_dump())\nreturn http.handle_response(TestInputTestInputPost, response) \n</code></pre> <p>We can see one of the functions here, <code>HealthCheckHealthCheckGet</code>, is for a straight-forward HTTP GET request without any input arguments, and it returns a schema object. If the endpoint has url parameters or query parameters, they will appear as input arguments to the function.</p> <pre><code>def HealthCheckHealthCheckGet() -&gt; schemas.HealthCheckResponse:\nresponse = http.get(\"/health-check\")\nreturn http.handle_response(HealthCheckHealthCheckGet, response)\n</code></pre> <p>Here is how you might use it:</p> <pre><code>from my_client import client\nclient.HealthCheckHealthCheckGet()\n&gt;&gt;&gt; HealthCheckResponse(status='ok')\n</code></pre> <p>A more complex example is shown just below - <code>TestInputTestInputPost</code>, this is for an HTTP POST method, and it requires an input property called <code>data</code> that is an instance of a schema, and returns a union of responses. If the endpoint has url parameters or query parameters, they will appear as input arguments to the function alongside the <code>data</code> argument.</p> <pre><code>def TestInputTestInputPost(\ndata: schemas.TestInputData,\n) -&gt; typing.Union[schemas.HTTPValidationError, schemas.TestInputResponse]:\nresponse = http.post(\"/test-input\", data=data and data.model_dump())\nreturn http.handle_response(TestInputTestInputPost, response) \n</code></pre> <p>Here is how you might use it:</p> <pre><code>from my_client import client, schemas\ndata = schemas.TestInputData(my_title=\"Hello, world\")\nclient.TestInputTestInputPost(data=data)\n&gt;&gt;&gt; TestInputResponse(title='Hello, world')\n</code></pre> <p>Because we're using Pydantic to manage the input data, we get a strongly-typed interface for us.</p>"},{"location":"examples/#schemaspy","title":"schemas.py","text":"<p>This file has all the possible schemas, request and response, for the API.</p> <p>They are all subclassed from pydantic's <code>BaseModel</code>. Here are a few examples:</p> my_client/schemas.py<pre><code>import typing  # noqa\nfrom pydantic import BaseModel  # noqa\nfrom enum import Enum  # noqa\nclass HTTPValidationError(BaseModel):\ndetail: list[typing.Any]\nclass HealthCheckResponse(BaseModel):\nstatus: str\nclass TestInputData(BaseModel):\nmy_title: str\nclass TestInputResponse(BaseModel):\ntitle: str\nclass ValidationError(BaseModel):\nloc: list[typing.Any]\nmsg: str\ntype: str\n</code></pre>"},{"location":"examples/#httppy","title":"http.py","text":"<p>This file manages the HTTP layer of the client.</p> <p>You should never need to touch the code here, but feel free to have a browse.</p> <p>This file will have either a sync, or an async instance of a client from <code>httpx</code>.</p> <p>It also manages the coersion of response bodies into schema objects.</p>"},{"location":"examples/#constantspy","title":"constants.py","text":"<p>This manages all the configuration your client might need.</p> <p>This file is only ever generated once, and will never be overwritten (unless you delete it yourself).</p> <p>You can modify the contents of the functions in this file to provide things like the base url and authentication keys for your client.</p>"},{"location":"examples/#manifest","title":"MANIFEST","text":"<p>The <code>MANIFEST</code> file provides some information on how the client was generated.</p>"},{"location":"install/","title":"\ud83c\udfd7\ufe0f Install","text":"<p>We recommend installing with pipx as a global CLI command.</p> <pre><code>sudo pipx install clientele\n</code></pre>"},{"location":"usage/","title":"\ud83d\udcdd Usage","text":"<p>Clientele provides a single command, <code>generate</code>, for generating your API Clients.</p>"},{"location":"usage/#from-a-url","title":"From a URL","text":"<p>Assuming the OpenAPI schema is available on the internet somewhere, you can query it to generate your client.</p> <pre><code>clientele generate -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/simple.json -o my_client/\n</code></pre> <p>Note</p> <p>The example above uses a test OpenAPI format, and will work if you copy/paste it!</p>"},{"location":"usage/#from-a-file","title":"From a file","text":"<p>Alternatively, if you have a local file you can use it to generate your client.</p> <pre><code>clientele generate -f path/to/file.json -o my_client/\n</code></pre>"},{"location":"usage/#async-client","title":"Async Client","text":"<p>If you prefer an asyncio client, just pass <code>--asyncio t</code> to your command.</p> <pre><code>clientele generate -f path/to/file.json -o my_client/ --asyncio t\n</code></pre> <p>Note</p> <p>You can use this command later to swap between a sync and async client so long as the OpenAPI schema remains the same, so don't worry about making a hard decision now.</p>"},{"location":"usage/#authentication","title":"Authentication","text":"<p>If your OpenAPI spec provides security information for the following authentication methods:</p> <ul> <li>HTTP Bearer</li> <li>HTTP Basic</li> </ul> <p>Then clientele will provide you information on the environment variables you need to set to make this work during the generation. For example:</p> <pre><code>Please see my_client/constants.py to set authentication variables\n</code></pre> <p>The <code>constants.py</code> file will have entry points for you to configure, for example, HTTP Bearer authentication will need the <code>get_bearer_token</code> function to be updated, something like this:</p> <pre><code>def get_bearer_token() -&gt; str:\n\"\"\"\n    HTTP Bearer authentication.\n    Used by many authentication methods - token, jwt, etc.\n    Does not require the \"Bearer\" content, just the key as a string.\n    \"\"\"\nfrom os import environ\nreturn environ.get(\"MY_AUTHENTICATION_TOKEN\")\n</code></pre>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>One of the problems with auto-generated clients is that you often need to configure them, and if you try and regenerate the client at some point (say because you've added new endpoints or fixed a bug) then your configuration gets wiped clean and you have to do it all over again.</p> <p>Clientele solves this problem by providing an entry point for configuration that will never be overwritten - <code>constants.py</code>.</p> <p>When you first generate the project, you will see a file called <code>my_client/constants.py</code> (assuming your <code>-o</code> was <code>my_client/</code>), and it'll look a bit like this:</p> <pre><code>\"\"\"\nThis file will never be updated on subsequent clientele runs.\nUse it as a space to store configuration and constants.\nDO NOT CHANGE THE FUNCTION NAMES\n\"\"\"\ndef api_base_url() -&gt; str:\n\"\"\"\n    Modify this function to provide the current api_base_url.\n    \"\"\"\nreturn \"http://localhost\"\n</code></pre> <p>Subsequent runs of the <code>generate</code> command will not change this file the first time is made, so you are free to modify the defaults to suit your needs, for example, if you need to source the base url of your API for different configurations, you can modify the <code>api_base_url</code> function like this:</p> <pre><code>from my_project import my_config\ndef api_base_url() -&gt; str:\n\"\"\"\n    Modify this function to provide the current api_base_url.\n    \"\"\"\nif my_config.debug:\nreturn \"http://localhost:8000\"\nelif my_config.production:\nreturn \"http://my-production-url.com\"\n</code></pre>"}]}